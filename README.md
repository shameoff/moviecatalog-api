# API для приложения каталога фильмов

## Описание

### Структура проекта

На первый взгляд, на главной странице достаточно много непонятных файликов, но давайте по порядку.

**composer.json** и **composer.lock** - файлы конфигурации для инициализации модулей php composer'а. <br>
**Dockerfile** и **docker-compose.yml** - файлы конфигурации для контейнеризации приложения, БД и админки к БД. <br>
**.env-example** - файл, где перечислены необходимые переменные окружения. Переназвать в **.env** и поменять значения в целях безопасности. <br>
**.htaccess** - файл конфигурации Apache сервера
**openAPI** - спецификация, по которой и делается API

В папке **database** лежат скрипты инициализации БД при создании контейнера (также там есть скрипты для наполнения некоторых таблиц для тестов) и папка с данными БД, проброшенная из контейнера.

В папке **application** очевидно, лежит само приложение.
 
#### Подробнее об **application**:

Папка **core** содержит в себе самые главные классы: запрос, ответ, роутер, роут, адаптерБД, родительские классы контроллера, сервиса и представления.

В папке **routes** лежат файлы с роутами, которые способен принимать сайт. На текущий момент это только роуты с api и возможно часть из них не работает, но структура располагает к расширению.

**autoloadClasses.php** позволяет подгружать любой класс без явного указания в коде, дабы не писать лишнего.

Остальные папки логически соотносятся с содержимым

### Как работает

+ Пользователь отправляет запрос на host/route/etc..., запрос улавливает апач и перенаправляет его в корень проекта, где всё, что идёт после host записывается в перменную `$_SERVER["REQUEST_URI"]`
+ Файл **index.php** является точкой входа в приложения. В нём подгружается файл конфигурации, создаются объекты запроса и ответа, затем вызывается роутер. 
+ Роутер сверяет полученный url с теми роутами, что прописаны в файлах папки **application\routes**, если нашёл совпадение, вызывает метод контроллера, который указан в роуте. 
+ Контроллер в зависимости от метода или создаёт модель и вызывает метод или вызывает метод, от которого ожидает получить модель, и на основе этого в объект класса **Response** присваивает статус-код, хедеры и контент.
+ В сервисах происходит взаимодействие с БД и другая бизнес-логика
+ Затем всё это дело возвращается в файл **index.php**, где вызывается метод `sendResponse()`

## Как пользоваться

С виндой разбирайтесь сами, я убил слишком много времени, чтобы разобраться на линуксе, повторять с виндой не хочу.

#### Конфигурация, на которой всё это дело проверено и запускается: Ubuntu MATE 22.04. Дальше ход действий: 

* Установить Apache сервер, включить у него модули *php* и *rewrite* создать в sites-available конфигурацию для нашего сайта. Проверить, что в глобальном конфиге апача разрешён overwrite и symlinks в папке /var/www.
* Создать символьную ссылку на проект в папке, убедиться, что у www-data есть права запуска и чтения к ссылке и ко всем папкам, предшествующим корню проекта, включая сам проект
* В папке проекта создаём файл .env, можно скопировать в него содержимое из .env-example или создать по его образу и подобию. Важно, чтобы файл назывался именно .env, иначе поломается и чините сами
* Устанавливаем composer затем в папке проекта прописываем `composer install`, чтобы подтянулся модуль Symfony\dotenv (и другие зависимости, если вдруг понадобятся) 
* Запускаем БД, убеждаемся, что приложение может к ней подключиться по кредам в .env

### Запуск БД

Я рекомендую запускать БД через `docker-compose up`, так как в таком случае все инит скрипты сделают всё за вас. Но тут на всё ваша воля.

В инит скриптах генераторы нужны лишь для показа результата и в реальном проекте будут избыточны.

## Дополнительно

Файлик **openAPI.json** можно загрузить в постман и упростить себе задачу с написанием запросов для проверки